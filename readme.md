برنامه با اجرای main()   شروع می شود که اول با فراخوانی signal()  مانع بسته شدن برنامه در صورت ctrl + c می شود.
با  printf() صفحه ابتدایی نمایش داده می شود.
در حلقه while(1) ابتدا path پوشه ای که هستیم رو چاپ میکند و بعد prompt>>>  و بعد تابع takeinput برای گرفتن ورودی و بررسی آن فراخوانی میشود (در takeinput  زیاد یا خالی بودن ورودی و ctrl + d   و ctrl + c  رو بررسی میکنیم)
سپس در تابع processString() ، pipe  بودن دستور را با تابع Parsepipe   بررسی میکنیم(وجود کاراکتر ‘|’ را بررسی میکنیم) بعد ورودی را به parseSpace  می دهیم تا ورودی parse شده را در ارایه ذخیره کند و چک میکنیم که دستور وارد شده از نوع دستورات سیستم است یا از دستوراتی که خودم تعریف کردم اگر بود که با تابع (ownCmd)  مدیریت میکنم و اگر نبود با تابع execArgs  و فرزند ایجاد می کنیم و آرایه ها را به عنوان ورودی execvp پاس میدم .
در تابع execArgsPiped()   دستورهایی که از pipe استفاده میکنند را مدیریت میکند. (خروجی دستور اول  را بعنوان ورودی دستور دوم به کار می بریم). 
تابع ownCmd()  دستور cd  را به chdir می دهیم، برای history همه ی دستورات وارد شده را در ارایه ذخیره میکنیم. در دستور msg  با توابع writeMsg  و readMsg پیام ارسال میکنیم و هر بار در حلقه while(1)  اینکه پیامی برای دریافت هست یا نه را چک میکنم. دستور help   دستوراتی که shell اجرا میکند را نشان میدهم.

